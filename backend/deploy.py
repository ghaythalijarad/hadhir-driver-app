#!/usr/bin/env python3
"""Deployment helper for driver profile infra (dev).

Creates or updates:
 1. DynamoDB table: DriverProfiles_dev (On-Demand) with GSIs: email-index, phone-index
 2. Lambda function: driver-profile-post-confirmation (Python) with env DRIVER_TABLE
 3. IAM role & policy (least privilege PutItem + logs)
 4. Attaches Lambda as Post Confirmation trigger to existing Cognito User Pool

Idempotent: safe to re-run.

Prerequisites:
  - AWS credentials/profile configured (export AWS_PROFILE=..., AWS_REGION=us-east-1)
  - boto3 installed (pip install boto3)

Usage:
  python backend/deploy.py --region us-east-1 --user-pool-id us-east-1_xDptXxzaI --stage dev
"""
from __future__ import annotations
import argparse
import json
import os
import sys
import tempfile
import time
import zipfile
from pathlib import Path
from typing import Optional

import boto3
from botocore.exceptions import ClientError
import random

TABLE_BASE_NAME = "DriverProfiles"
LAMBDA_NAME = "driver-profile-post-confirmation"
# New API Lambda constants
API_LAMBDA_NAME = "driver-profile-api"
HTTP_API_NAME_BASE = "driver-profile-api"
HTTP_API_STAGE = "dev"
LAMBDA_FILENAME = "index.py"
LAMBDA_HANDLER = "index.handler"
LAMBDA_RUNTIME = "python3.11"
ROLE_NAME_BASE = "driver_profile_post_confirmation_role"
POLICY_NAME_BASE = "driver_profile_post_confirmation_policy"
# New API role/policy base names
API_ROLE_NAME_BASE = "driver_profile_api_role"
API_POLICY_NAME_BASE = "driver_profile_api_policy"

LAMBDA_CODE = """# Generated by deploy.py
import os
import time
import json
import boto3

dynamodb = boto3.resource('dynamodb')
TABLE_NAME = os.environ['DRIVER_TABLE']

def handler(event, context):
    # Cognito Post Confirmation trigger
    # https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-post-confirmation.html
    try:
        if event.get('triggerSource') not in ('PostConfirmation_ConfirmSignUp', 'PostConfirmation_ConfirmForgotPassword'):
            return event

        attrs = event.get('request', {}).get('userAttributes', {}) or {}
        sub = attrs.get('sub')  # unique UUID
        if not sub:
            print('No sub in user attributes; skipping PutItem')
            return event

        table = dynamodb.Table(TABLE_NAME)

        # Prepare baseline profile
        item = {
            'driverId': sub,
            'email': attrs.get('email', ''),
            'phone': attrs.get('phone_number', ''),
            'name': attrs.get('name', ''),
            'status': 'PENDING_PROFILE',  # will change after app collects full details
            'createdAt': int(time.time()),
            'updatedAt': int(time.time()),
            'version': 1,
        }

        # Idempotent put (only create if not exists)
        try:
            table.put_item(
                Item=item,
                ConditionExpression='attribute_not_exists(driverId)'
            )
            print(f"Driver profile created for {sub}")
        except Exception as e:  # ConditionalCheckFailedException -> already exists
            print(f"PutItem skipped/failed: {e}")

    except Exception as e:
        print(f"[ERROR] handler exception: {e}")

    return event
"""

# New: Lambda code for HTTP API (GET/PUT /driver/me)
API_LAMBDA_CODE = """# Generated by deploy.py (driver-profile-api)
import os
import json
import time
import boto3
from decimal import Decimal

TABLE_NAME = os.environ['DRIVER_TABLE']
ddb = boto3.resource('dynamodb')

def _response(status, body):
    return {
        'statusCode': status,
        'headers': {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': '*',
            'Access-Control-Allow-Methods': 'GET,PUT,OPTIONS',
        },
        'body': json.dumps(body, default=_json_default)
    }

def _json_default(o):
    if isinstance(o, Decimal):
        return float(o)
    return str(o)

ALLOWED_UPDATE_FIELDS = {
    'name', 'city', 'vehicleType', 'licenseNumber', 'nationalId', 'docs', 'status'
}


def handler(event, context):
    try:
        # HTTP API v2 requestContext
        rc = event.get('requestContext', {})
        http = rc.get('http', {})
        method = http.get('method', 'GET')
        authorizer = rc.get('authorizer', {})
        jwt = authorizer.get('jwt', {})
        claims = jwt.get('claims', {})
        sub = claims.get('sub')
        if not sub:
            return _response(401, {'success': False, 'message': 'Unauthorized'})

        table = ddb.Table(TABLE_NAME)

        if method == 'GET':
            res = table.get_item(Key={'driverId': sub})
            item = res.get('Item')
            if not item:
                return _response(404, {'success': False, 'message': 'Profile not found'})
            return _response(200, {'success': True, 'data': item})

        if method == 'PUT':
            try:
                body = json.loads(event.get('body') or '{}')
            except Exception:
                return _response(400, {'success': False, 'message': 'Invalid JSON body'})

            # Filter allowed fields only
            update_data = {k: v for k, v in (body or {}).items() if k in ALLOWED_UPDATE_FIELDS}
            if not update_data:
                return _response(400, {'success': False, 'message': 'No allowed fields to update'})

            # Build UpdateExpression
            update_expr = ['updatedAt = :u']
            expr_vals = {':u': int(time.time())}
            expr_names = {}
            for i, (k, v) in enumerate(update_data.items()):
                placeholder = f"#f{i}"
                update_expr.append(f"{placeholder} = :v{i}")
                expr_names[placeholder] = k
                expr_vals[f":v{i}"] = v

            resp = table.update_item(
                Key={'driverId': sub},
                UpdateExpression='SET ' + ', '.join(update_expr),
                ExpressionAttributeNames=expr_names,
                ExpressionAttributeValues=expr_vals,
                ReturnValues='ALL_NEW'
            )
            return _response(200, {'success': True, 'data': resp.get('Attributes')})

        if method == 'OPTIONS':
            return _response(204, {})

        return _response(405, {'success': False, 'message': 'Method Not Allowed'})

    except Exception as e:
        print(f"[ERROR] {e}")
        return _response(500, {'success': False, 'message': 'Internal Server Error'})
"""


def ensure_table(dynamo, table_name: str):
    client = dynamo.meta.client
    try:
        desc = client.describe_table(TableName=table_name)
        print(f"✔ Table {table_name} exists (status={desc['Table']['TableStatus']})")
        # Ensure GSIs present; if missing, add.
        existing_gsis = {g['IndexName'] for g in desc['Table'].get('GlobalSecondaryIndexes', [])}
        required = {
            'email-index': {
                'IndexName': 'email-index',
                'KeySchema': [{'AttributeName': 'email', 'KeyType': 'HASH'}],
                'Projection': {'ProjectionType': 'ALL'},
            },
            'phone-index': {
                'IndexName': 'phone-index',
                'KeySchema': [{'AttributeName': 'phone', 'KeyType': 'HASH'}],
                'Projection': {'ProjectionType': 'ALL'},
            }
        }
        add_gsis = [spec for name, spec in required.items() if name not in existing_gsis]
        if add_gsis:
            # Need to know attribute definitions for new GSIs
            attr_defs = []
            for spec in add_gsis:
                for ks in spec['KeySchema']:
                    if ks['AttributeName'] not in [a['AttributeName'] for a in desc['Table']['AttributeDefinitions'] + attr_defs]:
                        attr_defs.append({'AttributeName': ks['AttributeName'], 'AttributeType': 'S'})
            print(f"Adding GSIs: {[g['IndexName'] for g in add_gsis]} (this will take a few minutes)...")
            client.update_table(
                TableName=table_name,
                AttributeDefinitions=desc['Table']['AttributeDefinitions'] + attr_defs,
                GlobalSecondaryIndexUpdates=[{'Create': g} for g in add_gsis]
            )
            wait_for_active(client, table_name)
            print("✔ GSIs added")
        return
    except client.exceptions.ResourceNotFoundException:
        pass

    print(f"Creating table {table_name} ...")
    client.create_table(
        TableName=table_name,
        AttributeDefinitions=[
            {'AttributeName': 'driverId', 'AttributeType': 'S'},
            {'AttributeName': 'email', 'AttributeType': 'S'},
            {'AttributeName': 'phone', 'AttributeType': 'S'},
        ],
        KeySchema=[{'AttributeName': 'driverId', 'KeyType': 'HASH'}],
        BillingMode='PAY_PER_REQUEST',
        GlobalSecondaryIndexes=[
            {
                'IndexName': 'email-index',
                'KeySchema': [{'AttributeName': 'email', 'KeyType': 'HASH'}],
                'Projection': {'ProjectionType': 'ALL'},
            },
            {
                'IndexName': 'phone-index',
                'KeySchema': [{'AttributeName': 'phone', 'KeyType': 'HASH'}],
                'Projection': {'ProjectionType': 'ALL'},
            }
        ],
        SSESpecification={'Enabled': True},
        Tags=[{'Key': 'Project', 'Value': 'DriverProfiles'}, {'Key': 'Stage', 'Value': table_name.split('_')[-1]}]
    )
    wait_for_active(client, table_name)
    print(f"✔ Table {table_name} created")


def wait_for_active(client, table_name: str):
    while True:
        desc = client.describe_table(TableName=table_name)
        status = desc['Table']['TableStatus']
        if status == 'ACTIVE':
            break
        print(f"  Waiting for table to be ACTIVE (current={status})...")
        time.sleep(5)


def ensure_lambda(role_arn: str, region: str, table_name: str) -> str:
    lambda_client = boto3.client('lambda', region_name=region)
    # Package code to zip in memory
    with tempfile.TemporaryDirectory() as td:
        p = Path(td) / LAMBDA_FILENAME
        p.write_text(LAMBDA_CODE)
        zip_path = Path(td) / 'function.zip'
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.write(p, arcname=LAMBDA_FILENAME)
        code_bytes = zip_path.read_bytes()

    try:
        resp = lambda_client.get_function(FunctionName=LAMBDA_NAME)
        # Update code & env if needed
        print(f"✔ Lambda {LAMBDA_NAME} exists, updating code/env ...")
        lambda_client.update_function_code(FunctionName=LAMBDA_NAME, ZipFile=code_bytes, Publish=True)
        # Retry configuration update if another update is in progress
        max_attempts = 8
        for attempt in range(1, max_attempts + 1):
            try:
                lambda_client.update_function_configuration(
                    FunctionName=LAMBDA_NAME,
                    Environment={'Variables': {'DRIVER_TABLE': table_name}},
                    Role=role_arn
                )
                break
            except ClientError as e:
                msg = str(e)
                if 'ResourceConflictException' in msg or 'operation cannot be performed at this time' in msg:
                    wait = min(5 * (2 ** (attempt - 1)), 60) + random.uniform(0, 1)
                    print(f"  Update in progress, retrying config update {attempt}/{max_attempts} after {wait:.1f}s ...")
                    time.sleep(wait)
                    continue
                else:
                    raise
        else:
            print("⚠ Skipped updating configuration after retries (will continue).")
        return resp['Configuration']['FunctionArn']
    except lambda_client.exceptions.ResourceNotFoundException:
        pass

    print(f"Creating Lambda {LAMBDA_NAME} ...")
    # Retry create to handle eventual consistency of IAM role propagation
    last_err = None
    for attempt in range(1, 7):
        try:
            resp = lambda_client.create_function(
                FunctionName=LAMBDA_NAME,
                Runtime=LAMBDA_RUNTIME,
                Role=role_arn,
                Handler=LAMBDA_HANDLER,
                Code={'ZipFile': code_bytes},
                Description='Post confirmation trigger to create baseline driver profile record',
                Timeout=10,
                MemorySize=128,
                Publish=True,
                Environment={'Variables': {'DRIVER_TABLE': table_name}},
            )
            print(f"✔ Lambda created: {resp['FunctionArn']}")
            return resp['FunctionArn']
        except ClientError as e:
            last_err = e
            msg = str(e)
            if 'cannot be assumed by Lambda' in msg or 'InvalidParameterValueException' in msg:
                wait = min(5 * (2 ** (attempt - 1)), 60) + random.uniform(0, 1)
                print(f"  IAM role not propagated yet. Retry {attempt}/6 after {wait:.1f}s ...")
                time.sleep(wait)
                continue
            else:
                raise
    if last_err is None:
        raise Exception("Failed to create Lambda after retries")
    raise last_err


# New: ensure API Lambda (GET/PUT)
def ensure_api_lambda(role_arn: str, region: str, table_name: str) -> str:
    lambda_client = boto3.client('lambda', region_name=region)
    # Package code
    with tempfile.TemporaryDirectory() as td:
        p = Path(td) / LAMBDA_FILENAME
        p.write_text(API_LAMBDA_CODE)
        zip_path = Path(td) / 'function.zip'
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.write(p, arcname=LAMBDA_FILENAME)
        code_bytes = zip_path.read_bytes()

    try:
        resp = lambda_client.get_function(FunctionName=API_LAMBDA_NAME)
        print(f"✔ Lambda {API_LAMBDA_NAME} exists, updating code/env ...")
        lambda_client.update_function_code(FunctionName=API_LAMBDA_NAME, ZipFile=code_bytes, Publish=True)
        lambda_client.update_function_configuration(
            FunctionName=API_LAMBDA_NAME,
            Environment={'Variables': {'DRIVER_TABLE': table_name}},
            Role=role_arn
        )
        return resp['Configuration']['FunctionArn']
    except lambda_client.exceptions.ResourceNotFoundException:
        pass

    print(f"Creating Lambda {API_LAMBDA_NAME} ...")
    resp = lambda_client.create_function(
        FunctionName=API_LAMBDA_NAME,
        Runtime=LAMBDA_RUNTIME,
        Role=role_arn,
        Handler=LAMBDA_HANDLER,
        Code={'ZipFile': code_bytes},
        Description='HTTP API for driver profile (GET/PUT /driver/me)',
        Timeout=10,
        MemorySize=128,
        Publish=True,
        Environment={'Variables': {'DRIVER_TABLE': table_name}},
    )
    print(f"✔ Lambda created: {resp['FunctionArn']}")
    return resp['FunctionArn']


def ensure_iam_role(region: str, table_arn: str, stage: str) -> str:
    iam = boto3.client('iam')
    role_name = f"{ROLE_NAME_BASE}_{stage}"
    policy_name = f"{POLICY_NAME_BASE}_{stage}"
    assume_policy = {
        'Version': '2012-10-17',
        'Statement': [{'Effect': 'Allow', 'Principal': {'Service': 'lambda.amazonaws.com'}, 'Action': 'sts:AssumeRole'}]
    }
    try:
        iam.get_role(RoleName=role_name)
        print(f"✔ IAM role {role_name} exists")
    except iam.exceptions.NoSuchEntityException:
        print(f"Creating IAM role {role_name} ...")
        iam.create_role(RoleName=role_name, AssumeRolePolicyDocument=json.dumps(assume_policy), Tags=[{'Key': 'Stage', 'Value': stage}])
        # Allow CloudWatch logs
        iam.attach_role_policy(RoleName=role_name, PolicyArn='arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole')
        # Give IAM time to propagate
        time.sleep(20)

    # Create/put inline policy for DynamoDB PutItem
    policy_doc = {
        'Version': '2012-10-17',
        'Statement': [
            {
                'Effect': 'Allow',
                'Action': ['dynamodb:PutItem'],
                'Resource': table_arn
            }
        ]
    }
    iam.put_role_policy(RoleName=role_name, PolicyName=policy_name, PolicyDocument=json.dumps(policy_doc))
    role_arn = iam.get_role(RoleName=role_name)['Role']['Arn']
    print(f"✔ IAM policy attached (PutItem only)")
    return role_arn

# New: IAM role for API Lambda (GetItem/UpdateItem)
def ensure_api_iam_role(region: str, table_arn: str, stage: str) -> str:
    iam = boto3.client('iam')
    role_name = f"{API_ROLE_NAME_BASE}_{stage}"
    policy_name = f"{API_POLICY_NAME_BASE}_{stage}"
    assume_policy = {
        'Version': '2012-10-17',
        'Statement': [{'Effect': 'Allow', 'Principal': {'Service': 'lambda.amazonaws.com'}, 'Action': 'sts:AssumeRole'}]
    }
    try:
        iam.get_role(RoleName=role_name)
        print(f"✔ IAM role {role_name} exists")
    except iam.exceptions.NoSuchEntityException:
        print(f"Creating IAM role {role_name} ...")
        iam.create_role(RoleName=role_name, AssumeRolePolicyDocument=json.dumps(assume_policy), Tags=[{'Key': 'Stage', 'Value': stage}])
        iam.attach_role_policy(RoleName=role_name, PolicyArn='arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole')
        time.sleep(10)

    policy_doc = {
        'Version': '2012-10-17',
        'Statement': [
            {'Effect': 'Allow', 'Action': ['dynamodb:GetItem', 'dynamodb:UpdateItem'], 'Resource': table_arn}
        ]
    }
    iam.put_role_policy(RoleName=role_name, PolicyName=policy_name, PolicyDocument=json.dumps(policy_doc))
    role_arn = iam.get_role(RoleName=role_name)['Role']['Arn']
    print("✔ API IAM policy attached (GetItem/UpdateItem only)")
    return role_arn


# New: API Gateway HTTP API with Cognito JWT authorizer and routes

def ensure_http_api(region: str, user_pool_id: str, stage: str, lambda_arn: str, app_client_id: str | None = None):
    apigw = boto3.client('apigatewayv2', region_name=region)
    sts = boto3.client('sts')
    account_id = sts.get_caller_identity()['Account']
    user_pool_arn = f"arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}"

    # Create or get API
    apis = apigw.get_apis()['Items']
    api_name = f"{HTTP_API_NAME_BASE}-{stage}"
    api = next((a for a in apis if a['Name'] == api_name), None)
    if api:
        api_id = api['ApiId']
        print(f"✔ HTTP API exists: {api_name} ({api_id})")
    else:
        resp = apigw.create_api(Name=api_name, ProtocolType='HTTP', CorsConfiguration={
            'AllowOrigins': ['*'],
            'AllowMethods': ['GET', 'PUT', 'OPTIONS'],
            'AllowHeaders': ['*']
        })
        api_id = resp['ApiId']
        print(f"✔ HTTP API created: {api_name} ({api_id})")

    # Create or get JWT authorizer
    auths = apigw.get_authorizers(ApiId=api_id)['Items']
    authorizer = next((a for a in auths if a['Name'] == 'cognito-jwt'), None)
    desired_jwt_cfg = {
        'Audience': [app_client_id] if app_client_id else [],
        'Issuer': f"https://cognito-idp.{region}.amazonaws.com/{user_pool_id}",
    }
    if authorizer:
        authorizer_id = authorizer['AuthorizerId']
        # Update authorizer if audience differs
        current = authorizer.get('JwtConfiguration', {})
        curr_aud = sorted(current.get('Audience') or [])
        want_aud = sorted(desired_jwt_cfg['Audience'])
        if curr_aud != want_aud:
            apigw.update_authorizer(
                ApiId=api_id,
                AuthorizerId=authorizer_id,
                AuthorizerType='JWT',
                IdentitySource=['$request.header.Authorization'],
                Name='cognito-jwt',
                JwtConfiguration=desired_jwt_cfg,
            )
            print("✔ JWT authorizer updated with audience")
        else:
            print("✔ JWT authorizer exists")
    else:
        resp = apigw.create_authorizer(
            ApiId=api_id,
            AuthorizerType='JWT',
            IdentitySource=['$request.header.Authorization'],
            Name='cognito-jwt',
            JwtConfiguration=desired_jwt_cfg
        )
        authorizer_id = resp['AuthorizerId']
        print("✔ JWT authorizer created")

    # Create Lambda integration
    integrations = apigw.get_integrations(ApiId=api_id)['Items']
    integration = next((i for i in integrations if i.get('IntegrationUri', '').endswith(f":function:{API_LAMBDA_NAME}")), None)
    if integration:
        integration_id = integration['IntegrationId']
        print("✔ Lambda integration exists")
    else:
        resp = apigw.create_integration(
            ApiId=api_id,
            IntegrationType='AWS_PROXY',
            IntegrationUri=lambda_arn,
            PayloadFormatVersion='2.0'
        )
        integration_id = resp['IntegrationId']
        print("✔ Lambda integration created")

    # Helper to upsert a route
    def upsert_route(route_key: str):
        routes = apigw.get_routes(ApiId=api_id)['Items']
        route = next((r for r in routes if r['RouteKey'] == route_key), None)
        if route:
            print(f"✔ Route exists: {route_key}")
            return route['RouteId']
        resp = apigw.create_route(
            ApiId=api_id,
            RouteKey=route_key,
            AuthorizationType='JWT',
            AuthorizerId=authorizer_id,
            Target=f"integrations/{integration_id}"
        )
        print(f"✔ Route created: {route_key}")
        return resp['RouteId']

    upsert_route('GET /driver/me')
    upsert_route('PUT /driver/me')

    # Create or update stage
    stages = apigw.get_stages(ApiId=api_id)['Items']
    stage_obj = next((s for s in stages if s['StageName'] == stage), None)
    if stage_obj:
        print(f"✔ Stage exists: {stage}")
    else:
        apigw.create_stage(ApiId=api_id, StageName=stage, AutoDeploy=True)
        print(f"✔ Stage created: {stage}")

    # Add permission for API Gateway to invoke Lambda
    lambda_client = boto3.client('lambda', region_name=region)
    source_arn = f"arn:aws:execute-api:{region}:{account_id}:{api_id}/*/*/driver/me"
    for sid in ("apigw-invoke-get", "apigw-invoke-put"):
        try:
            lambda_client.add_permission(
                FunctionName=API_LAMBDA_NAME,
                StatementId=f"{sid}-{api_id}",
                Action='lambda:InvokeFunction',
                Principal='apigateway.amazonaws.com',
                SourceArn=source_arn,
            )
            print(f"✔ Added Lambda invoke permission: {sid}")
        except ClientError as e:
            if e.response.get('Error', {}).get('Code') == 'ResourceConflictException':
                print(f"✔ Invoke permission exists: {sid}")
            else:
                raise

    return f"https://{api_id}.execute-api.{region}.amazonaws.com/{stage}"


def ensure_lambda_invoke_permission(user_pool_id: str, region: str):
    lambda_client = boto3.client('lambda', region_name=region)
    sts = boto3.client('sts')
    account_id = sts.get_caller_identity()['Account']
    source_arn = f"arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}"
    statement_id = f"cognito-invoke-{user_pool_id}"
    try:
        lambda_client.add_permission(
            FunctionName=LAMBDA_NAME,
            StatementId=statement_id,
            Action='lambda:InvokeFunction',
            Principal='cognito-idp.amazonaws.com',
            SourceArn=source_arn,
        )
        print("✔ Added permission for Cognito to invoke Lambda")
    except ClientError as e:
        if e.response.get('Error', {}).get('Code') == 'ResourceConflictException':
            print("✔ Invoke permission already exists")
        else:
            raise


def ensure_trigger(user_pool_id: str, region: str, lambda_arn: str):
    cognito = boto3.client('cognito-idp', region_name=region)
    desc = cognito.describe_user_pool(UserPoolId=user_pool_id)['UserPool']
    lambda_config = desc.get('LambdaConfig', {})
    current = lambda_config.get('PostConfirmation')
    if current == lambda_arn:
        print("✔ PostConfirmation trigger already set to desired Lambda")
        return
    if current and current != lambda_arn:
        print(f"Updating PostConfirmation trigger from {current} -> {lambda_arn}")
    else:
        print(f"Setting PostConfirmation trigger to {lambda_arn}")
    lambda_config['PostConfirmation'] = lambda_arn
    cognito.update_user_pool(UserPoolId=user_pool_id, LambdaConfig=lambda_config)
    print("✔ Cognito PostConfirmation trigger configured")


def parse_args():
    ap = argparse.ArgumentParser()
    ap.add_argument('--region', default=os.getenv('AWS_REGION', 'us-east-1'))
    ap.add_argument('--user-pool-id', required=True)
    ap.add_argument('--stage', default='dev')
    ap.add_argument('--table-suffix', default='dev', help='Suffix after table base name, default dev (DriverProfiles_dev)')
    ap.add_argument('--app-client-id', default=os.getenv('COGNITO_APP_CLIENT_ID', ''), help='Cognito App Client ID for JWT audience')
    return ap.parse_args()


def main():
    args = parse_args()
    region = args.region
    dynamo = boto3.resource('dynamodb', region_name=region)

    table_name = f"{TABLE_BASE_NAME}_{args.table_suffix}" if not TABLE_BASE_NAME.endswith(f"_{args.table_suffix}") else TABLE_BASE_NAME

    ensure_table(dynamo, table_name)
    # Get table ARN using a client explicitly
    dynamo_client = boto3.client('dynamodb', region_name=region)
    table_arn = dynamo_client.describe_table(TableName=table_name)['Table']['TableArn']

    role_arn = ensure_iam_role(region, table_arn, args.stage)
    lambda_arn = ensure_lambda(role_arn, region, table_name)
    ensure_lambda_invoke_permission(args.user_pool_id, region)
    ensure_trigger(args.user_pool_id, region, lambda_arn)

    # New: API stack
    api_role_arn = ensure_api_iam_role(region, table_arn, args.stage)
    api_lambda_arn = ensure_api_lambda(api_role_arn, region, table_name)
    api_url = ensure_http_api(region, args.user_pool_id, args.stage, api_lambda_arn, args.app_client_id or None)

    print("\nDeployment summary:")
    print(f"  Region: {region}")
    print(f"  Table: {table_name}")
    print(f"  Lambda Trigger: {lambda_arn}")
    print(f"  API Lambda: {api_lambda_arn}")
    print(f"  HTTP API URL: {api_url}")
    print(f"  UserPool: {args.user_pool_id}")
    if args.app_client_id:
        print(f"  App Client ID (audience): {args.app_client_id}")
    print("✔ All resources ensured.")


if __name__ == '__main__':
    try:
        main()
    except ClientError as e:
        print(f"AWS ClientError: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
